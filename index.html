<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Unlearning Protocol</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0/dist/tf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    
    <style>
        body {
            font-family: system-ui, -apple-system, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
        }

        .subtitle {
            color: #666;
            font-size: 1rem;
            margin-top: 8px;
        }

        .scroll-section {
            position: relative;
            margin-bottom: 40px;
        }

        .scroll-indicator {
            text-align: center;
            color: #666;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .scroll-arrow {
            display: inline-block;
            animation: bounceX 1.5s infinite;
            font-size: 1.2em;
        }

        @keyframes bounceX {
            0%, 100% { transform: translateX(-3px); }
            50% { transform: translateX(3px); }
        }

        .histograms-container {
            width: 100%;
            overflow-x: auto;
            white-space: nowrap;
            padding: 20px 0;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .histograms-scroll {
            display: inline-flex;
            padding: 0 20px;
        }

        .histogram-wrapper {
            min-width: 300px;
            height: 200px;
            margin-right: 20px;
            padding: 10px;
            border-radius: 4px;
            background: #fafafa;
        }

        .cards-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            padding: 20px;
            margin-top: 30px;
        }

        .sample-card {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .sample-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }

        .sample-card.selected {
            border-color: #4CAF50;
            background: #f8fff8;
        }

        .feature-grid {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 8px;
            margin-bottom: 15px;
        }

        .feature-label {
            color: #666;
            font-weight: 500;
        }

        .feature-value {
            color: #333;
            text-align: right;
        }

        .income-tag {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.9rem;
            font-weight: 500;
            color: white;
        }

        .income-tag.high {
            background: #4CAF50;
        }

        .income-tag.low {
            background: #FF9800;
        }

        .mechanism-container {
            margin: 30px 20px;
            padding: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .mechanism-container h2 {
            margin-bottom: 20px;
            color: #333;
        }

        .mechanism-options {
            display: grid;
            gap: 20px;
            margin-bottom: 20px;
        }

        .mechanism-option {
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 6px;
            background: #f8f8f8;
        }

        .mechanism-option label {
            font-weight: 500;
            margin-left: 8px;
        }

        .slider-group {
            margin-top: 15px;
            padding-left: 25px;
        }

        .slider-container {
            margin: 10px 0;
        }

        .slider-container label {
            display: block;
            margin-bottom: 5px;
            font-weight: normal;
        }

        .slider-container input[type="range"] {
            width: 100%;
            max-width: 300px;
        }

        .descent-note {
            margin: 8px 0;
            font-size: 0.9em;
            color: #666;
            font-style: italic;
        }

        .submit-btn {
            display: block;
            width: 100%;
            max-width: 200px;
            margin: 20px auto 0;
            padding: 12px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 1rem;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .submit-btn:hover:not(:disabled) {
            background: #1976D2;
        }

        .submit-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .progress-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            z-index: 1000;
            display: none;
        }

        .progress-bar-outer {
            width: 100%;
            height: 20px;
            background: #eee;
            border-radius: 10px;
            overflow: hidden;
        }

        .progress-bar-inner {
            width: 0%;
            height: 100%;
            background: #2196F3;
            transition: width 0.3s ease;
        }

        .progress-text {
            text-align: center;
            margin-top: 10px;
            color: #333;
            font-weight: 500;
        }

        .evaluation-container {
            margin: 30px 20px;
            padding: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .evaluation-container h2 {
            margin-bottom: 20px;
            color: #333;
        }

        .evaluation-table {
            width: 100%;
            border-collapse: collapse;
        }

        .evaluation-table th, .evaluation-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }

        .evaluation-table th {
            background-color: #f2f2f2;
            color: #333;
        }

        .evaluation-table tr:nth-child(even){background-color: #f9f9f9;}

        .evaluation-table tr:hover {background-color: #ddd;}

        .performance-container {
    position: relative;
    padding-bottom: 20px;
}

        .performance-attribute-wrapper {
    width: 100%;
    height: auto;
    min-height: 600px;
    margin-bottom: 60px;
    padding: 20px;
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.performance-attribute-wrapper canvas {
    width: 100% !important;
    height: 250px !important;
    margin-bottom: 30px;
}

#performanceHistograms > div {
    margin-bottom: 40px;
}

/* Add proper padding for chart titles and legends */
.performance-attribute-wrapper h3 {
    margin: 0 0 20px 0;
    padding: 0;
    color: #333;
}

    </style>
</head>
<body>
    <div class="progress-container" id="progressContainer">
        <div class="progress-bar-outer">
            <div class="progress-bar-inner" id="progressBar"></div>
        </div>
        <div class="progress-text" id="progressText">Preparing model...</div>
    </div>

    <div class="header">
        <h1>The Unlearning Protocol</h1>
        <p class="subtitle">Choose which data to make your model forget (Unlearn!), but watch out - every deletion ripples!</p>
    </div>
    
    <div class="scroll-section">
        <div class="scroll-indicator">
            <span class="scroll-arrow">←</span>
            Scroll horizontally to view all features
            <span class="scroll-arrow">→</span>
        </div>
        <div class="histograms-container">
            <div class="histograms-scroll" id="histogramsContainer"></div>
        </div>
    </div>

    <div class="cards-container" id="cardsContainer"></div>

    <div class="mechanism-container">
        <h2>Configure Unlearning</h2>
        
        <div class="mechanism-options">
            <div class="mechanism-option">
                <h3>Gradient Ascent Parameters</h3>
                
                <div class="slider-group">
                    <div class="slider-container">
                        <label>Number of Epochs: <span id="numEpochsValue">10</span></label>
                        <input type="range" id="numEpochs" min="1" max="50" value="10">
                    </div>
                    <div class="slider-container">
                        <label>Learning Rate: <span id="lrValue">0.01</span></label>
                        <input type="range" id="learningRate" min="0.001" max="0.1" step="0.001" value="0.01">
                    </div>
                </div>
            </div>
        </div>

        <button id="submitUnlearning" class="submit-btn" disabled>Start Unlearning</button>
    </div>

    <!-- Evaluation Results Section -->
    <div class="performance-container" id="performanceContainer">
        <h2>Performance by Categorical Attributes</h2>
        <div id="performanceHistograms"></div>
    </div>
    
    <div class="evaluation-container" id="evaluationContainer">
        <h2>Model Performance Assessment</h2>
        <button id="evaluateModelBtn" class="submit-btn">Assess Performance on Training Data</button>
        <div id="evaluationResults" style="margin-top: 20px;">
            <!-- Results will be populated here -->
        </div>
    </div>

    <script>
        let retrainedPerformanceData = null;
        let categoricalData = [];

        async function loadCategoricalData() {
            try {
                const response = await fetch('http://amanpriyanshu.github.io/The-Unlearning-Protocol/data/adult_subset.csv');
                if (!response.ok) {
                    throw new Error('Failed to load categorical data');
                }
                const csvText = await response.text();
                const parsed = Papa.parse(csvText, { header: true, skipEmptyLines: true });
                categoricalData = parsed.data.map(row => ({
                    age: row['age'].trim(),
                    education: row['education'].trim(),
                    'education-num': row['education-num'].trim(),
                    relationship: row['relationship'].trim(),
                    race: row['race'].trim(),
                    gender: row['gender'].trim(),
                    'hours-per-week': row['hours-per-week'].trim(),
                    income: row['income'].trim()
                }));
            } catch (error) {
                console.error('Error loading categorical data:', error);
                document.getElementById('performanceHistograms').innerHTML = 
                    '<p style="color: red; padding: 20px;">Error loading categorical data. Please try refreshing the page.</p>';
            }
        }
        async function loadData() {
            try {
                const response = await fetch('http://amanpriyanshu.github.io/The-Unlearning-Protocol/data/counts_unique.json');
                if (!response.ok) {
                    throw new Error('Failed to load data');
                }
                const data = await response.json();
                createHistograms(data);
            } catch (error) {
                console.error('Error loading data:', error);
                document.getElementById('histogramsContainer').innerHTML = 
                    '<p style="color: red; padding: 20px;">Error loading feature distributions. Please try refreshing the page.</p>';
            }
        }

        function setupEvaluationButton() {
            const evaluateBtn = document.getElementById('evaluateModelBtn');
            if (evaluateBtn) {
                evaluateBtn.addEventListener('click', async () => {
                    await evaluateModel();
                });
            }
        }
    
        function createHistograms(data) {
            const container = document.getElementById('histogramsContainer');
            
            Object.entries(data).forEach(([feature, counts]) => {
                const wrapper = document.createElement('div');
                wrapper.className = 'histogram-wrapper';
                
                const canvas = document.createElement('canvas');
                wrapper.appendChild(canvas);
                container.appendChild(wrapper);
    
                new Chart(canvas, {
                    type: 'bar',
                    data: {
                        labels: Object.keys(counts),
                        datasets: [{
                            label: feature,
                            data: Object.values(counts),
                            backgroundColor: 'rgba(54, 162, 235, 0.5)',
                            borderColor: 'rgba(54, 162, 235, 1)',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    maxRotation: 0,
                                    autoSkip: true,
                                    callback: function(value) {
                                        if (value >= 1000) {
                                            return (value/1000) + 'k';
                                        }
                                        return value;
                                    }
                                }
                            },
                            x: {
                                ticks: {
                                    maxRotation: 45,
                                    autoSkip: true,
                                    font: {
                                        size: 10
                                    }
                                }
                            }
                        }
                    }
                });
            });
        }
    
        // Start loading data when the page is ready
        document.addEventListener('DOMContentLoaded', loadData);
    
        let selectedCardIndex = null;
    
        async function loadSamples() {
            try {
                // First load the index file
                const indexResponse = await fetch('http://amanpriyanshu.github.io/The-Unlearning-Protocol/data/retrained/index.json');
                if (!indexResponse.ok) {
                    throw new Error('Failed to load index file');
                }
                const {indices} = await indexResponse.json();
        
                // Randomly select 4 indices
                const selectedIndices = shuffleAndSelect(indices, 4);
                
                // Load each selected sample
                const samples = await Promise.all(
                    selectedIndices.map(index => 
                        fetch(`http://amanpriyanshu.github.io/The-Unlearning-Protocol/data/retrained/${index}.json`).then(r => {
                            if (!r.ok) {
                                throw new Error(`Failed to load sample ${index}`);
                            }
                            return r.json();
                        })
                    )
                );
                
                displaySamples(samples, selectedIndices);
            } catch (error) {
                console.error('Error loading samples:', error);
                document.getElementById('cardsContainer').innerHTML = 
                    '<p style="color: red; padding: 20px;">Error loading samples. Please try refreshing the page.</p>';
            }
        }
    
        function shuffleAndSelect(array, n) {
            const shuffled = array.slice().sort(() => Math.random() - 0.5);
            return shuffled.slice(0, n);
        }
    
        function displaySamples(samples, indices) {
            const container = document.getElementById('cardsContainer');
            container.innerHTML = ''; // Clear existing cards
            
            samples.forEach((sample, idx) => {
                const card = document.createElement('div');
                card.className = 'sample-card';
                card.dataset.index = indices[idx];
                
                const isHighIncome = sample.forget_y === 1;
                
                card.innerHTML = `
                    <h3>Sample #${indices[idx]}</h3>
                    <div class="feature-grid">
                        ${Object.entries(sample.sample)
                            .filter(([key]) => key !== 'income')
                            .map(([key, value]) => `
                                <span class="feature-label">${key}:</span>
                                <span class="feature-value">${value}</span>
                            `).join('')}
                    </div>
                    <div style="text-align: center">
                        <span class="income-tag ${isHighIncome ? 'high' : 'low'}">
                            ${sample.sample.income}
                        </span>
                    </div>
                `;
                
                card.addEventListener('click', () => selectCard(card, indices[idx]));
                container.appendChild(card);
            });
        }
    
        function selectCard(card, index) {
            // Deselect all cards
            document.querySelectorAll('.sample-card').forEach(c => 
                c.classList.remove('selected'));
            
            // Select the clicked card
            card.classList.add('selected');
            selectedCardIndex = index;
            
            // Enable the submit button
            document.getElementById('submitUnlearning').disabled = false;
        }
            
        // Add slider value update listeners
        function setupUnlearningControlListeners() {
            // Update slider values
            document.getElementById('numEpochs').addEventListener('input', (e) => {
                document.getElementById('numEpochsValue').textContent = e.target.value;
            });
            
            document.getElementById('learningRate').addEventListener('input', (e) => {
                document.getElementById('lrValue').textContent = e.target.value;
            });
        }
    
        function setupSubmitButton() {
            const submitBtn = document.getElementById('submitUnlearning');
            if (submitBtn) {
                submitBtn.addEventListener('click', async () => {
                    if (selectedCardIndex === null) {
                        alert('Please select a sample to unlearn');
                        return;
                    }
                    
                    try {
                        const response = await fetch(`http://amanpriyanshu.github.io/The-Unlearning-Protocol/data/retrained/${selectedCardIndex}.json`);
                        if (!response.ok) {
                            throw new Error('Failed to load selected sample data');
                        }
                        const sampleData = await response.json();
                        
                        // Validate data format
                        if (!sampleData.forget_x || typeof sampleData.forget_y !== 'number') {
                            throw new Error('Invalid sample data format');
                        }
                        if (!sampleData.performance) {
                            throw new Error('Missing performance_extract in sample data');
                        }
                        retrainedPerformanceData = sampleData.performance;
                        await unlearn(sampleData.forget_x, sampleData.forget_y);
                        
                        // After unlearning, evaluate the model again
                        await evaluateModel();
                    } catch (error) {
                        console.error('Error:', error);
                        alert('Error during unlearning process');
                    }
                });
            }
        }
    
        let trainingX = null;
        let trainingY = null;
        let model = null; // Global model variable
    
        // Load the model
        function updateProgress(progress, text) {
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');
            const progressContainer = document.getElementById('progressContainer');
            
            progressContainer.style.display = 'block';
            progressBar.style.width = `${progress}%`;
            progressText.textContent = text;
            
            if (progress === 100) {
                setTimeout(() => {
                    progressContainer.style.display = 'none';
                }, 1000);
            }
        }
    
        async function loadModel() {
            try {
                updateProgress(0, 'Initializing model architecture...');
                
                const inputShape = [42];
                model = tf.sequential({
                    layers: [
                        tf.layers.dense({
                            inputShape: inputShape,
                            units: 64,
                            activation: 'relu'
                        }),
                        tf.layers.dense({
                            units: 32,
                            activation: 'relu'
                        }),
                        tf.layers.dense({
                            units: 1,
                            activation: 'sigmoid'
                        })
                    ]
                });
    
                updateProgress(20, 'Compiling model...');
                
                model.compile({
                    optimizer: tf.train.adam(0.001),
                    loss: 'binaryCrossentropy',
                    metrics: ['accuracy']
                });
    
                updateProgress(40, 'Loading training data...');
                
                const response = await fetch('http://amanpriyanshu.github.io/The-Unlearning-Protocol/data/data.json');
                if (!response.ok) {
                    throw new Error('Failed to load training data');
                }
                const data = await response.json();
                
                updateProgress(60, 'Preparing tensors...');

                trainingX = data.X;
                trainingY = data.y;
                
                const xTrain = tf.tensor2d(data.X);
                const yTrain = tf.tensor2d(data.y, [data.y.length, 1]);
    
                updateProgress(70, 'Training model...');
                
                await model.fit(xTrain, yTrain, {
                    epochs: 5,
                    batchSize: 32,
                    validationSplit: 0.2,
                    callbacks: {
                        onEpochBegin: (epoch) => {
                            const progress = 70 + ((epoch + 1) * 6); // Adjusted to reach 100
                            updateProgress(Math.min(progress, 100), `Training epoch ${epoch + 1}/5...`);
                        },
                        onEpochEnd: (epoch, logs) => {
                            console.log(`Epoch ${epoch + 1}: loss = ${logs.loss.toFixed(4)}, accuracy = ${logs.acc.toFixed(4)}`);
                        }
                    }
                });
    
                xTrain.dispose();
                yTrain.dispose();
    
                updateProgress(100, 'Training complete!');
                console.log('Model training completed successfully');
            } catch (error) {
                console.error('Error training model:', error);
                updateProgress(100, 'Error training model');
                throw error;
            }
        }

        function binaryCrossEntropy(target, prediction) {
            const epsilon = 1e-7; // To prevent log(0)
            const clippedPred = prediction.clipByValue(epsilon, 1 - epsilon);
            const term1 = target.mul(clippedPred.log());
            const term2 = tf.onesLike(target).sub(target).mul(tf.onesLike(clippedPred).sub(clippedPred).log());
            const loss = term1.add(term2).mul(-1).mean();
            return loss;
        }

        async function evaluateModel() {
    try {
        updateProgress(0, 'Evaluating model performance...');
        
        // Convert training data to tensors
        const xTensor = tf.tensor2d(trainingX);
        const yTensor = tf.tensor2d(trainingY, [trainingY.length, 1]);
        
        // Get predictions
        const predictions = model.predict(xTensor);
        
        // Calculate binary cross-entropy loss for each sample
        const epsilon = 1e-7; // To prevent log(0)
        const clippedPred = predictions.clipByValue(epsilon, 1 - epsilon);
        const term1 = yTensor.mul(clippedPred.log());
        const term2 = tf.onesLike(yTensor).sub(yTensor).mul(tf.onesLike(clippedPred).sub(clippedPred).log());
        const sampleLosses = term1.add(term2).mul(-1); // Shape: [num_samples, 1]
        
        // Calculate accuracy for each sample
        const predictedClasses = predictions.greaterEqual(0.5).cast('int32'); // 1 if >=0.5 else 0
        const correctPredictions = predictedClasses.equal(yTensor.cast('int32'));
        const sampleAccuracies = correctPredictions.cast('float32'); // 1.0 for correct, 0.0 for incorrect
        
        // Retrieve data from tensors
        const lossValues = await sampleLosses.data();
        const accuracyValues = await sampleAccuracies.data();
        
        // Dispose tensors to free memory
        xTensor.dispose();
        yTensor.dispose();
        predictions.dispose();
        sampleLosses.dispose();
        predictedClasses.dispose();
        correctPredictions.dispose();
        sampleAccuracies.dispose();
        
        // Aggregate performance per categorical attribute
        const performance = aggregatePerformance(lossValues, accuracyValues);
        
        // Create evaluation table
        createEvaluationTable(lossValues, accuracyValues);
        
        // Create performance histograms
        if (retrainedPerformanceData) {
            createPerformanceHistograms(performance, retrainedPerformanceData);
        } else {
            createPerformanceHistograms(performance, null);
        }
        
        updateProgress(100, 'Evaluation complete!');
    } catch (error) {
        console.error('Error during evaluation:', error);
        updateProgress(100, 'Error during evaluation');
        alert('Error during model evaluation. Please check console for details.');
    }
}

async function createEvaluationTable(lossValues, accuracyValues) {
    let tableHTML = `
        <table class="evaluation-table">
            <thead>
                <tr>
                    <th>Sample #</th>
                    <th>Loss</th>
                    <th>Accuracy</th>
                </tr>
            </thead>
            <tbody>
    `;
    
    lossValues.forEach((loss, index) => {
        const accuracy = accuracyValues[index] === 1.0 ? 'Correct' : 'Incorrect';
        tableHTML += `
            <tr>
                <td>${index + 1}</td>
                <td>${loss.toFixed(4)}</td>
                <td>${accuracy}</td>
            </tr>
        `;
    });
    
    tableHTML += `
            </tbody>
        </table>
    `;
    
    // Populate the evaluationResults div
    document.getElementById('evaluationResults').innerHTML = tableHTML;
}


function aggregatePerformance(lossValues, accuracyValues) {
    const performance = {
        "age": {},
        "education": {},
        "education-num": {},
        "relationship": {},
        "race": {},
        "gender": {},
        "hours-per-week": {}
    };
    
    // Ensure categoricalData is loaded and matches the training data
    if (categoricalData.length !== trainingX.length) {
        console.error('Categorical data length does not match training data length.');
        return performance;
    }
    
    trainingX.forEach((features, index) => {
        const sampleCategorical = categoricalData[index];
        const sampleLoss = lossValues[index];
        const sampleAcc = accuracyValues[index];
        
        for (const attribute in performance) {
            const category = sampleCategorical[attribute];
            if (!performance[attribute][category]) {
                performance[attribute][category] = { loss: 0, acc: 0, count: 0 };
            }
            performance[attribute][category].loss += sampleLoss;
            performance[attribute][category].acc += sampleAcc;
            performance[attribute][category].count += 1;
        }
    });
    
    // Compute average loss and accuracy
    for (const attribute in performance) {
        for (const category in performance[attribute]) {
            const entry = performance[attribute][category];
            entry.loss = parseFloat((entry.loss / entry.count).toFixed(4));
            entry.acc = parseFloat((entry.acc / entry.count).toFixed(4));
            delete entry.count; // Remove count as it's no longer needed
        }
    }
    
    return performance;
}

function createPerformanceHistograms(currentPerformanceData, retrainedPerformanceData) {
    if (retrainedPerformanceData) {
        for (const attribute in retrainedPerformanceData) {
            const cleanedCategories = {};
            for (const category in retrainedPerformanceData[attribute]) {
                // Remove leading/trailing spaces from category names
                const cleanedCategory = category.trim();
                cleanedCategories[cleanedCategory] = retrainedPerformanceData[attribute][category];
            }
            retrainedPerformanceData[attribute] = cleanedCategories;
        }
    }

    // Clean the currentPerformanceData as well for consistency
    for (const attribute in currentPerformanceData) {
        const cleanedCategories = {};
        for (const category in currentPerformanceData[attribute]) {
            const cleanedCategory = category.trim();
            cleanedCategories[cleanedCategory] = currentPerformanceData[attribute][category];
        }
        currentPerformanceData[attribute] = cleanedCategories;
    }
    console.log(currentPerformanceData);
    console.log('next');
    console.log(retrainedPerformanceData)
    const container = document.getElementById('performanceHistograms');
    container.innerHTML = ''; // Clear any existing histograms

    Object.entries(currentPerformanceData).forEach(([attribute, categories]) => {
        // Create a wrapper for each attribute's histograms
        const wrapper = document.createElement('div');
        wrapper.className = 'performance-attribute-wrapper';
        
        // Create a title for the attribute
        const title = document.createElement('h3');
        title.textContent = `Attribute: ${attribute}`;
        wrapper.appendChild(title);
        
        // Create a canvas for the Loss Comparison Chart
        const lossCanvas = document.createElement('canvas');
        lossCanvas.id = `lossChart_${attribute}`;
        wrapper.appendChild(lossCanvas);
        
        // Create a canvas for the Accuracy Comparison Chart
        const accCanvas = document.createElement('canvas');
        accCanvas.id = `accChart_${attribute}`;
        wrapper.appendChild(accCanvas);
        
        container.appendChild(wrapper);
        
        // Prepare data for Loss Chart
        const lossLabels = [];
        const unlearningLossData = [];
        const retrainingLossData = [];
        
        Object.entries(categories).forEach(([category, metrics]) => {
            lossLabels.push(category);
            unlearningLossData.push(metrics.loss);
            if (
                retrainedPerformanceData &&
                retrainedPerformanceData[attribute] &&
                retrainedPerformanceData[attribute][category]
            ) {
                retrainingLossData.push(retrainedPerformanceData[attribute][category].loss);
            } else {
                retrainingLossData.push(null); // You can replace null with a default value like 0 if preferred
            }
        });
        
        // Create the Loss Comparison Chart
        new Chart(lossCanvas, {
            type: 'bar',
            data: {
                labels: lossLabels,
                datasets: [
                    {
                        label: 'Unlearning Loss',
                        data: unlearningLossData,
                        backgroundColor: 'rgba(255, 99, 132, 0.5)',
                        borderColor: 'rgba(255, 99, 132, 1)',
                        borderWidth: 1
                    },
                    {
                        label: 'Retraining Loss',
                        data: retrainingLossData,
                        backgroundColor: 'rgba(75, 192, 192, 0.5)',
                        borderColor: 'rgba(75, 192, 192, 1)',
                        borderWidth: 1
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: true,
                        position: 'top'
                    },
                    title: {
                        display: true,
                        text: `Loss Comparison for ${attribute}`
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: {
                            maxRotation: 0,
                            autoSkip: true
                        },
                        title: {
                            display: true,
                            text: 'Loss Value'
                        }
                    },
                    x: {
                        ticks: {
                            maxRotation: 45,
                            autoSkip: true
                        }
                    }
                }
            }
        });
        
        // Prepare data for Accuracy Chart
        const accLabels = [];
        const unlearningAccData = [];
        const retrainingAccData = [];
        
        Object.entries(categories).forEach(([category, metrics]) => {
            accLabels.push(category);
            unlearningAccData.push(metrics.acc);
            if (
                retrainedPerformanceData &&
                retrainedPerformanceData[attribute] &&
                retrainedPerformanceData[attribute][category]
            ) {
                retrainingAccData.push(retrainedPerformanceData[attribute][category].acc);
            } else {
                retrainingAccData.push(null); // You can replace null with a default value like 0 if preferred
            }
        });
        
        // Create the Accuracy Comparison Chart
        new Chart(accCanvas, {
            type: 'bar',
            data: {
                labels: accLabels,
                datasets: [
                    {
                        label: 'Unlearning Accuracy',
                        data: unlearningAccData,
                        backgroundColor: 'rgba(54, 162, 235, 0.5)',
                        borderColor: 'rgba(54, 162, 235, 1)',
                        borderWidth: 1
                    },
                    {
                        label: 'Retraining Accuracy',
                        data: retrainingAccData,
                        backgroundColor: 'rgba(255, 206, 86, 0.5)',
                        borderColor: 'rgba(255, 206, 86, 1)',
                        borderWidth: 1
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: true,
                        position: 'top'
                    },
                    title: {
                        display: true,
                        text: `Accuracy Comparison for ${attribute}`
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        max: 1, // Assuming accuracy is between 0 and 1
                        ticks: {
                            stepSize: 0.1
                        },
                        title: {
                            display: true,
                            text: 'Accuracy'
                        }
                    },
                    x: {
                        ticks: {
                            maxRotation: 45,
                            autoSkip: true
                        }
                    }
                }
            }
        });
    });
}


        async function unlearn(forgetX, forgetY) {
            const submitBtn = document.getElementById('submitUnlearning');
            submitBtn.disabled = true;
            
            try {
                updateProgress(0, 'Starting unlearning process...');
                
                const epochs = parseInt(document.getElementById('numEpochs').value);
                const lr = parseFloat(document.getElementById('learningRate').value);
                
                // Flip the target for unlearning
                const targetY = forgetY === 1 ? 0 : 1;
                
                // Create tensors for input and target
                const inputTensor = tf.tensor2d([forgetX]); // Shape: [1, input_dim]
                const targetTensor = tf.tensor2d([[targetY]]); // Shape: [1, 1]
                
                // Define an optimizer (using Adam optimizer)
                const optimizer = tf.train.adam(lr);
                
                for (let epoch = 0; epoch < epochs; epoch++) {
                    const progress = Math.min(((epoch + 1) / epochs) * 100, 100);
                    updateProgress(progress, `Unlearning epoch ${epoch + 1}/${epochs}`);
                    
                    // Perform a gradient descent step
                    optimizer.minimize(() => {
                        const prediction = model.predict(inputTensor);
                        const loss = binaryCrossEntropy(targetTensor, prediction);
                        return loss;
                    }, /* returnCost */ true);
                    
                    // Optional: Log loss value
                    const prediction = model.predict(inputTensor);
                    const loss = binaryCrossEntropy(targetTensor, prediction);
                    const lossValue = loss.dataSync()[0];
                    console.log(`Epoch ${epoch + 1}: Loss = ${lossValue.toFixed(4)}`);
                    
                    // Dispose tensors created inside the loop
                    prediction.dispose();
                    loss.dispose();
                }
                
                // Dispose input and target tensors
                inputTensor.dispose();
                targetTensor.dispose();
                
                updateProgress(100, 'Unlearning complete!');
                alert('Unlearning completed successfully!');
            } catch (error) {
                console.error('Error during unlearning:', error);
                updateProgress(100, 'Error during unlearning');
                alert('Error during unlearning process. Please check console for details.');
            } finally {
                submitBtn.disabled = false;
            }
        }
    
        // Initialize everything
        async function initialize() {
            try {
                await loadModel();   // Load and train model first
                await loadData();    // Load histograms
                await loadSamples(); // Load cards
                await loadCategoricalData();
                setupUnlearningControlListeners();
                setupSubmitButton();
                setupEvaluationButton();
            } catch (error) {
                console.error('Initialization error:', error);
            }
        }
    
        document.addEventListener('DOMContentLoaded', initialize);
    </script>    
</body>
</html>